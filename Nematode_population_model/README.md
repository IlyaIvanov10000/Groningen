## Summary

This code is used for the analysis of the population dynamics of the pathogenic nematode _Globodera pallida_ and its interaction with the potato plant. The file contains five functions that together were used to analyze the effect of a neuropeptide-based intervention strategy against _G. pallida_ for the 2020 iGEM competition.

## Overview

The code defines a set of Ordinary Differential Equations (ODEs) that govern the change in population size for several life stages of _G. pallida_. Additionally it calculates the damage inflicted upon the plant by the nematodes, resulting in both reduced crop yield and capacity to host nematodes. The remaining functions are used for analyzing and visualizing the results of the ODEs. 
The code is validated based on _G. pallida_ and the potato plant but the ODEs and corresponding parameters can be altered to represent any ecological system. The code is used by providing the relevant parameter values and using the analysis and visualization functions on the results generated by the function containing the ODEs.

## Basic Use

### Function #1: population_model

This function takes in three required arguments and 15 optional arguments. The three required arguments are the initial density of G. pallida eggs, the length of the time steps, and the type of soil in which the ecological scenario takes place. All optional arguments are parameter values which are set to a standard value for ease of use. The standard values are obtained through literature studies and experimental fitting. The user can signify which parameters will be altered and what their new value should be to investigate how different conditions alter the population dynamics.

Running the function computes the population sizes throughout the potato growing season (150 days) and outputs an array containing the time points and the population sizes at each time point.

A basic example is: 

    population_model(1, 0.1, ‘Sand’, b = 0.75)[1][1500]

This runs the population model with a starting egg density of 1 eggs per gram of soil, time steps of 0.1 days, a sandy soil. The parameter b is altered from its standard value of 0.5 to 0.75. The example returns the 1500th data point in the 1st column, i.e. the egg density at t = 150 days.

### Function #2: plot_dataset

This function takes in two lists of data points and turns them into a simple graphs. The function also allows you to name the x and y-axes of the resulting graph.

A basic example is: 

    plot_dataset(population_model(1, 0.1, 'Sand')[0], population_model(1, 0.1, 'Sand')[1], 'Time', 'Eggs')

In this example two list of data are generated with the population_model function. The data in the lists are the time points and the corresponding size of the population of eggs. The labels of the graph are thus also Time and Eggs.

### Function #3: final_vs_initial

This function repeatedly runs the population model with increasing values of the initial egg density, in a range specified by the user. The function generates two lists: one of the egg population size at t = 0 and one of the corresponding ratio between the egg population size at t = 150 and t = 0.

A basic example is: 

    final_vs_initial(0, 50, 1, 'Sand')[1]

This example returns a list of the final/initial egg density ratios of the population model with all standard parameter values and a sandy soil. The initial densities are 0, 1, 2... up to 50.

### Function #4: test_parameter_influence

This function repeatedly runs the population model while varying the value of one of the parameters. This can be used to investigate the sensitivity of the nematode population dynamics to these parameters. The parameter will be varied within a range and with a step size specified by the user. The output is two lists: one of the values of the parameter you varied, and one of the final egg density or damage inflicted on the roots for the given parameter value.

**IMPORTANT!** 

The function requires more than just the four arguments to work. The user must alter the code to change the desired parameter:

    population_model(1, 0.1, soil_type, Dummy = i)[1][1500]

Instead of ‘Dummy’ the user must write down the parameter, e.g K, that they wish to investigate. If the user wishes to test the sensitivity of the model to temperature or moisture, the user must instead keep ‘Dummy’ as it is and find the line in the population_model function and change the expression after the ‘=’ sign to ‘Dummy’:

    T = 4.75 + 14.09 * np.sin(0.01057 * t + 0.3018)’ (for temperature)

    moisture_percent = 30 + 10 * np.sin((2 / 243) * np.pi * t)’ (for moisture)

To alter whether you want to see the influence of the parameter on the egg density or on the damage dealt to the root, the user must alter the code:

    population_model(1, 0.1, soil_type, Dummy = i)[1][1500]

To see the final egg density choose column [1] of the population model, to see total damage inflicted choose column [7].

A basic example is: 

    def test_parameter_influence(start_range, end_range, steps, soil_type):
        data_points = [[],[]]
        for i in np.arange(start_range, end_range, steps):
            new_data = [i, population_model(1, 0.1, soil_type, b = i)[7][1500]]
            data_points[0].append(new_data[0])
            data_points[1].append(new_data[1])
        
        return data_points

    test_parameter_influence(0, 1, 0.05, 'Loam')[1]

Here the code is altered to make ‘b’ the parameter that is varied. This parameter is varied from 0 to 1 with steps of 0.05. The selected column of the population model is [7] so the damage dealt to the roots at t = 150 is the output that is analyzed in response to changing ‘b’.

### Function #5: nlp_bifurcation

This function varies the rate at which repelled nematodes recover from the effects of the nlp, i.e. ‘Rrs’ and investigates what the required efficacy of the RootPatch intervention method (‘Rcr’ * ‘nlp’) must be to reduce the damage inflicted on the potato plant by 50%. In this function, ‘Rcr’ is set to 1 so that the required RootPatch efficacy (‘Rcr’ * ‘nlp’) is equal to ‘nlp’, allowing this single parameter to describe the more complex concept of RootPatch efficacy. The function starts off with a value for ‘nlp’ specified by the user and a value for ‘Rrs’ that is 0. Then the value of ‘nlp’ is increased until X < 0.5. The function will do this for all values of ‘Rrs’ in the range specified by the user and will thus find the corresponding ‘nlp’ value. 

**IMPORTANT!** 

Because this function runs the population_model function many times, based on the ‘steps’ and ‘steps_nlp’ arguments, the user must be very careful in selecting these arguments. To keep the function runtime reasonably low (<30 min), ‘steps’ should be no more than 1/100th of the size of the range and ‘nlp’ must not be lower than 0.0001.
It is advised to select a starting value of nlp that is very close to, but always lower than, the value of N * Rcr for which an X < 0.5 can be achieved. The runtime will increase rapidly if the further the starting value of nlp is from this desired value. To find a good starting value of nlp, use the test_parameter_influence function to create a graph of X as a function of N and pick the value that closely approximates X = 0.5. Rrs * dt should NEVER be larger than 1. This will result in more than 100% of repelled nematodes to become unrepelled per time step, leading to negative values of R. With these conditions it cannot be guaranteed that the equations can be solved, leading to runtimes of hours before the program has exhausted all possible values of N.

A basic example is: 

    nlp_bifurcation(0, 1, 0.01, 0.0001, 10, 0.1, 'Loam')[1] 

Here ‘Rrs’ is varied from 0 to 1 with steps of 0.01 and ‘nlp’ is increased in steps of 0.001. Additionally the initial egg density, the time steps and the soil type are specified as 10, 0.1 and ‘Loam’ respectively. Column [1] is called as output in this example, meaning that the required ‘nlp’ value for a 50% damage reduction is used as the output.

Author: Sietse Couperus
